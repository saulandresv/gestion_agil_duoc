// Custom Service Worker for Inventory Management PWA
// This file will be processed by Vue CLI and copied to the dist folder

import { precacheAndRoute } from "workbox-precaching";

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

const CACHE_NAME = "inventario-v1";

// Handle skip waiting message from client
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    console.log("⏩ Skipping waiting and activating new service worker");
    self.skipWaiting();
  }
});

// Take control of all clients immediately after activation
self.addEventListener("activate", (event) => {
  console.log("🔄 Service worker activated");
  event.waitUntil(
    Promise.all([
      // Clean up old caches
      caches.keys().then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== CACHE_NAME) {
              console.log(`🗑️ Deleting old cache: ${cacheName}`);
              return caches.delete(cacheName);
            }
          })
        );
      }),
      // Take control of all clients
      self.clients.claim(),
    ])
  );
});

// Background Sync for pending operations
self.addEventListener("sync", (event) => {
  console.log("Background sync triggered:", event.tag);

  switch (event.tag) {
    case "sync-pending-requests":
      event.waitUntil(syncPendingRequests());
      break;
    case "sync-stock-updates":
      event.waitUntil(syncStockUpdates());
      break;
    case "sync-movements":
      event.waitUntil(syncPendingMovements());
      break;
    default:
      console.log("Unknown sync tag:", event.tag);
  }
});

// Sync pending request approvals/rejections
async function syncPendingRequests() {
  try {
    console.log("🔄 Syncing pending requests...");

    const pendingOps = await getPendingOperations("request_operations");

    for (const operation of pendingOps) {
      try {
        const apiUrl = await getApiUrl();
        let response;

        if (operation.type === "approve") {
          response = await fetch(
            `${apiUrl}/solicitudes/${operation.requestId}/approve`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(operation.data),
            }
          );
        } else if (operation.type === "reject") {
          response = await fetch(
            `${apiUrl}/solicitudes/${operation.requestId}/reject`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(operation.data),
            }
          );
        }

        if (response && response.ok) {
          await removePendingOperation("request_operations", operation.id);
          console.log(
            `✅ Synced ${operation.type} for request ${operation.requestId}`
          );

          // Send notification to user
          await self.registration.showNotification("Operación completada", {
            body: `Solicitud ${operation.requestId} ${
              operation.type === "approve" ? "aprobada" : "rechazada"
            } exitosamente`,
            icon: "/img/icons/android-chrome-192x192.png",
            badge: "/img/icons/android-chrome-192x192.png",
            tag: `request-${operation.requestId}`,
            data: { requestId: operation.requestId, type: operation.type },
          });
        }
      } catch (error) {
        console.error(`❌ Failed to sync operation ${operation.id}:`, error);
      }
    }
  } catch (error) {
    console.error("Error in syncPendingRequests:", error);
  }
}

// Sync stock level updates
async function syncStockUpdates() {
  try {
    console.log("📦 Syncing stock updates...");

    const pendingUpdates = await getPendingOperations("stock_updates");
    const apiUrl = await getApiUrl();

    for (const update of pendingUpdates) {
      try {
        const response = await fetch(
          `${apiUrl}/productos/${update.productId}`,
          {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ stock: update.newStock }),
          }
        );

        if (response.ok) {
          await removePendingOperation("stock_updates", update.id);
          console.log(`✅ Updated stock for product ${update.productId}`);
        }
      } catch (error) {
        console.error(
          `❌ Failed to update stock for product ${update.productId}:`,
          error
        );
      }
    }
  } catch (error) {
    console.error("Error in syncStockUpdates:", error);
  }
}

// Sync pending movements
async function syncPendingMovements() {
  try {
    console.log("📝 Syncing pending movements...");

    const pendingMovements = await getPendingOperations("pending_movements");
    const apiUrl = await getApiUrl();

    for (const movement of pendingMovements) {
      try {
        const response = await fetch(`${apiUrl}/movimientos/batch`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            movimientos: movement.movements,
            bodeguero: movement.bodeguero,
          }),
        });

        if (response.ok) {
          await removePendingOperation("pending_movements", movement.id);
          console.log(
            `✅ Synced batch movements: ${movement.movements.length} items`
          );
        }
      } catch (error) {
        console.error(
          `❌ Failed to sync movements batch ${movement.id}:`,
          error
        );
      }
    }
  } catch (error) {
    console.error("Error in syncPendingMovements:", error);
  }
}

// Handle notification clicks
self.addEventListener("notificationclick", (event) => {
  event.notification.close();

  if (event.action === "view") {
    // Open the app to the requests page
    event.waitUntil(clients.openWindow("/buscar-solicitud"));
  } else if (event.action === "dismiss") {
    // Do nothing, just close
    return;
  } else {
    // Default action - open the app
    event.waitUntil(clients.openWindow("/"));
  }
});

// Push notification handler
self.addEventListener("push", (event) => {
  if (!event.data) return;

  const data = event.data.json();

  const options = {
    body: data.body,
    icon: "/img/icons/android-chrome-192x192.png",
    badge: "/img/icons/android-chrome-192x192.png",
    tag: data.tag || "default",
    data: data.data || {},
  };

  event.waitUntil(self.registration.showNotification(data.title, options));
});

// Periodic background checks (when supported)
self.addEventListener("periodicsync", (event) => {
  console.log("Periodic sync triggered:", event.tag);

  if (event.tag === "check-pending-requests") {
    event.waitUntil(checkPendingRequests());
  }
});

// Check for new pending requests and notify user
async function checkPendingRequests() {
  try {
    const apiUrl = await getApiUrl();
    const response = await fetch(`${apiUrl}/solicitudes/pending`);

    if (response.ok) {
      const pendingRequests = await response.json();

      if (pendingRequests.length > 0) {
        await self.registration.showNotification(
          "Nuevas solicitudes pendientes",
          {
            body: `Tienes ${pendingRequests.length} solicitudes pendientes de revisión`,
            icon: "/img/icons/android-chrome-192x192.png",
            badge: "/img/icons/android-chrome-192x192.png",
            tag: "pending-requests",
            actions: [
              { action: "view", title: "Ver solicitudes" },
              { action: "dismiss", title: "Más tarde" },
            ],
            data: { count: pendingRequests.length },
          }
        );
      }
    }
  } catch (error) {
    console.error("Error checking pending requests:", error);
  }
}

// Helper to get API URL from environment or default
async function getApiUrl() {
  // Try to get from cached config first
  try {
    const cache = await caches.open(CACHE_NAME);
    const configResponse = await cache.match("/config.json");
    if (configResponse) {
      const config = await configResponse.json();
      return config.apiUrl;
    }
  } catch (error) {
    console.log("No cached config, using default");
  }

  // Fallback to default
  return "http://localhost:3000";
}

// IndexedDB helpers for storing pending operations
async function getPendingOperations(storeName) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("InventarioDB", 1);

    request.onerror = () => reject(request.error);

    request.onsuccess = () => {
      const db = request.result;

      if (!db.objectStoreNames.contains(storeName)) {
        resolve([]);
        return;
      }

      const transaction = db.transaction([storeName], "readonly");
      const store = transaction.objectStore(storeName);
      const getAllRequest = store.getAll();

      getAllRequest.onsuccess = () => resolve(getAllRequest.result);
      getAllRequest.onerror = () => reject(getAllRequest.error);
    };

    request.onupgradeneeded = () => {
      const db = request.result;
      if (!db.objectStoreNames.contains(storeName)) {
        db.createObjectStore(storeName, { keyPath: "id", autoIncrement: true });
      }
    };
  });
}

async function removePendingOperation(storeName, id) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("InventarioDB", 1);

    request.onsuccess = () => {
      const db = request.result;
      const transaction = db.transaction([storeName], "readwrite");
      const store = transaction.objectStore(storeName);
      const deleteRequest = store.delete(id);

      deleteRequest.onsuccess = () => resolve();
      deleteRequest.onerror = () => reject(deleteRequest.error);
    };

    request.onerror = () => reject(request.error);
  });
}

// Cache API responses for offline functionality
self.addEventListener("fetch", (event) => {
  // Only handle API requests
  if (
    event.request.url.includes("/api/") ||
    event.request.url.includes("/solicitudes/") ||
    event.request.url.includes("/productos/") ||
    event.request.url.includes("/movimientos/")
  ) {
    event.respondWith(
      fetch(event.request)
        .then((response) => {
          // Cache successful GET requests
          if (event.request.method === "GET" && response.ok) {
            const responseClone = response.clone();
            caches.open(CACHE_NAME).then((cache) => {
              cache.put(event.request, responseClone);
            });
          }
          return response;
        })
        .catch(() => {
          // Return cached version if available
          return caches.match(event.request);
        })
    );
  }
});
